const { Bot, session, InlineKeyboard } = require('grammy');
const { conversations, createConversation } = require('@grammyjs/conversations');
const config = require('./config');

// Bot initialization
const token = config.botToken;
const bot = new Bot(token);

// Initialize conversations with error handling wrapper
function wrapConversation(handler, name) {
    return createConversation(async (conversation, ctx) => {
        try {
            await handler(conversation, ctx);
        } catch (error) {
            console.error(`Conversation error in ${name}:`, error);
            await ctx.reply('‚ùå An error occurred during the conversation. Please try again.');
        }
    }, name);
}

// IMPORTANT: Add session middleware BEFORE conversations
bot.use(session({ initial: () => ({}) }));

// Initialize conversations middleware AFTER session
bot.use(conversations());

// Global error handler
bot.catch((err) => {
    const errorMessage = `Error while handling update ${err.ctx.update.update_id}:
    ${err.error.message}
    Stack: ${err.error.stack}`;
    console.error(errorMessage);
    
    try {
        err.ctx.reply('‚ùå An error occurred. Please try again or contact support.');
    } catch (replyError) {
        console.error('Failed to send error message:', replyError);
    }
});

// Import dependencies
const { getUser, isAdmin, expireInactiveUsers } = require('./db/db');
const { callFlow, registerCallCommand } = require('./commands/call');
const { addUserFlow, registerAddUserCommand } = require('./commands/adduser');
const { promoteFlow, registerPromoteCommand } = require('./commands/promote');
const { removeUserFlow, registerRemoveUserCommand } = require('./commands/removeuser');
const { smsFlow, bulkSmsFlow, scheduleSmsFlow, registerSmsCommands } = require('./commands/sms');

// Register conversations with error handling
bot.use(wrapConversation(callFlow, "call-conversation"));
bot.use(wrapConversation(addUserFlow, "adduser-conversation"));
bot.use(wrapConversation(promoteFlow, "promote-conversation"));
bot.use(wrapConversation(removeUserFlow, "remove-conversation"));
bot.use(wrapConversation(scheduleSmsFlow, "schedule-sms-conversation"));
bot.use(wrapConversation(smsFlow, "sms-conversation"));
bot.use(wrapConversation(bulkSmsFlow, "bulk-sms-conversation"));

// Register command handlers
registerCallCommand(bot);
registerAddUserCommand(bot);
registerPromoteCommand(bot);
registerRemoveUserCommand(bot);
registerSmsCommands(bot);


// Register non-conversation commands
require('./commands/users')(bot);
require('./commands/help')(bot);
require('./commands/menu')(bot);
require('./commands/guide')(bot);
require('./commands/transcript')(bot);
require('./commands/api')(bot);
require('./commands/webapp')(bot); // Register WebApp handler


// Start command handler
bot.command('start', async (ctx) => {
    try {
        expireInactiveUsers();
        
        let user = await new Promise(r => getUser(ctx.from.id, r));
        if (!user) {
            const kb = new InlineKeyboard()
                .text('üì± Contact Admin', `https://t.me/@${config.admin.username}`);
            
            return ctx.reply('*Access Restricted* ‚ö†Ô∏è\n\n' +
                'This bot requires authorization.\n' +
                'Please contact an administrator to get access.', {
                parse_mode: 'Markdown',
                reply_markup: kb
            });
        }

        const isOwner = await new Promise(r => isAdmin(ctx.from.id, r));
        
        // Prepare user information
        const userStats = `üë§ *User Information*
‚Ä¢ ID: \`${ctx.from.id}\`
‚Ä¢ Username: @${ctx.from.username || 'none'}
‚Ä¢ Role: ${user.role}
‚Ä¢ Joined: ${new Date(user.timestamp).toLocaleDateString()}`;

        const welcomeText = isOwner ? 
            'üõ°Ô∏è *Welcome, Administrator!*\n\nYou have full access to all bot features.' :
            'üëã *Welcome to Voicednut Bot!*\n\nYou can make voice calls using AI agents.';

        // Get the Mini App URL from config
        const webAppUrl = config.webAppUrl;
        
        // Prepare keyboard with Mini App button if URL is configured
        const kb = new InlineKeyboard();
        
        // Add Mini App button if URL is configured
        if (webAppUrl) {
            kb.webApp('üöÄ Open Mini App', webAppUrl)
              .row();
        }
        
        // Add other buttons
        kb.text('üìû New Call', 'CALL')
          .text('üìö Guide', 'GUIDE')
            .row()
            .text('üí¨ New Sms', 'SMS')
            .text('üè• Health', 'HEALTH')            
            .row()
            .text('‚ùî Help', 'HELP')
            .text('üìã Menu', 'MENU');

        if (isOwner) {
            kb.row()
                .text('‚ûï Add User', 'ADDUSER')
                .text('‚¨ÜÔ∏è Promote', 'PROMOTE')
                .row()
                .text('üë• Users', 'USERS')
                .text('‚ùå Remove', 'REMOVE');
        }

        // Prepare the message with conditional Mini App notice
        let message = `${welcomeText}\n\n${userStats}\n\n`;
        
        // Add Mini App notice only if it's configured
        if (config.webAppUrl) {
            message += 'üöÄ *Try our Mini App for a better experience!*\n' +
                      'Click the Mini App button below to access enhanced features.\n\n';
        }
        
        message += 'Use the buttons below or type /help for available commands.';
        
        await ctx.reply(message, {
            parse_mode: 'Markdown',
            reply_markup: kb
        });
    } catch (error) {
        console.error('Start command error:', error);
        await ctx.reply('‚ùå An error occurred. Please try again or contact support.');
    }
});

// Enhanced callback query handler
bot.on('callback_query:data', async (ctx) => {
    try {
        // Answer callback query immediately to prevent timeout
        await ctx.answerCallbackQuery();

        const action = ctx.callbackQuery.data;
        console.log(`Callback query received: ${action} from user ${ctx.from.id}`);

        // Verify user authorization
        const user = await new Promise(r => getUser(ctx.from.id, r));
        if (!user) {
            await ctx.reply("‚ùå You are not authorized to use this bot.");
            return;
        }

        // Check admin permissions
        const isAdminUser = user.role === 'ADMIN';
        const adminActions = ['ADDUSER', 'PROMOTE', 'REMOVE', 'USERS', 'STATUS', 'TEST_API'];
        
        if (adminActions.includes(action) && !isAdminUser) {
            await ctx.reply("‚ùå This action is for administrators only.");
            return;
        }

        // Handle conversation actions
        const conversations = {
            'CALL': 'call-conversation',
            'ADDUSER': 'adduser-conversation',
            'PROMOTE': 'promote-conversation',
            'REMOVE': 'remove-conversation',
            'SMS': 'sms-conversation',
            'BULK_SMS': 'bulk-sms-conversation',
            'SCHEDULE_SMS': 'schedule-sms-conversation'
        };

        if (conversations[action]) {
            console.log(`Starting conversation: ${conversations[action]}`);
            await ctx.reply(`Starting ${action.toLowerCase()} process...`);
            await ctx.conversation.enter(conversations[action]);
            return;
        }

        // Handle direct command actions
        switch (action) {
            case 'HELP':
                await executeHelpCommand(ctx, isAdminUser);
                break;
                
            case 'USERS':
                if (isAdminUser) {
                    try {
                        await executeUsersCommand(ctx);
                    } catch (usersError) {
                        console.error('Users callback error:', usersError);
                        await ctx.reply('‚ùå Error displaying users list. Please try again.');
                    }
                }
                break;
                
            case 'GUIDE':
                await executeGuideCommand(ctx);
                break;
                
            case 'MENU':
                await executeMenuCommand(ctx, isAdminUser);
                break;
                
            case 'HEALTH':
                await executeHealthCommand(ctx);
                break;
                
            case 'STATUS':
                if (isAdminUser) {
                    await executeStatusCommand(ctx);
                }
                break;
                
            case 'TEST_API':
                if (isAdminUser) {
                    await executeTestApiCommand(ctx);
                }
                break;
                
            case 'CALLS':
                await executeCallsCommand(ctx);
                break;

            case 'SMS':
                await ctx.reply(`Starting SMS process...`);
                await ctx.conversation.enter('sms-conversation');
                break;
                
            case 'BULK_SMS':
                if (isAdminUser) {
                    await ctx.reply(`Starting bulk SMS process...`);
                    await ctx.conversation.enter('bulk-sms-conversation');
                }
                break;
            
            case 'SCHEDULE_SMS':
                await ctx.reply(`Starting SMS scheduling...`);
                await ctx.conversation.enter('schedule-sms-conversation');
                break;
            
                case 'SMS_STATS':
                    if (isAdminUser) {
                        await executeCommand(ctx, 'smsstats');
                    }
                    break;
                
            default:
                console.log(`Unknown callback action: ${action}`);
                await ctx.reply("‚ùå Unknown action. Please try again.");
        }

    } catch (error) {
        console.error('Callback query error:', error);
        await ctx.reply("‚ùå An error occurred processing your request. Please try again.");
    }
});

// Command execution functions for inline buttons
async function executeHelpCommand(ctx) {
    try {
        // Check if user is authorized
        const user = await new Promise(r => getUser(ctx.from.id, r));
        if (!user) {
            return ctx.reply('‚ùå You are not authorized to use this bot.');
        }
        const isOwner = await new Promise(r => isAdmin(ctx.from.id, r));
        
        // Build help text using HTML formatting (more reliable)
        let helpText = `üì± <b>Basic Commands</b>
‚Ä¢ /start - Restart bot &amp; show main menu
‚Ä¢ /call - Start a new voice call
‚Ä¢ /app - Open the Mini App
‚Ä¢ /sms - Send an SMS message
‚Ä¢ /smsconversation &lt;phone&gt; - View SMS conversation
‚Ä¢ /transcript &lt;call_sid&gt; - Get call transcript
‚Ä¢ /calls [limit] - List recent calls (max 50)
‚Ä¢ /smstemplates - View available SMS templates
‚Ä¢ /smstemplate &lt;name&gt; - View specific template
‚Ä¢ /health or /ping - Check bot &amp; API health
‚Ä¢ /guide - Show detailed usage guide
‚Ä¢ /menu - Show quick action buttons
‚Ä¢ /help - Show this help message`;
        
        if (isOwner) {
            helpText += `
            
üëë <b>Admin Commands</b>
‚Ä¢ /adduser - Add new authorized user
‚Ä¢ /promote - Promote user to admin
‚Ä¢ /removeuser - Remove user access
‚Ä¢ /users - List all authorized users
‚Ä¢ /bulksms - Send bulk SMS messages
‚Ä¢ /schedulesms - Schedule SMS for later
‚Ä¢ /status - Full system status check
‚Ä¢ /testapi - Test API connection`;
        }
        
        helpText += `
        
üìñ <b>Quick Usage</b>
1. Use /call or click üìû Call button
2. Enter phone number (E.164 format: +1234567890)
3. Define agent behavior/prompt
4. Set initial message to be spoken
5. Monitor call progress and receive notifications

üí° <b>Examples</b>
‚Ä¢ Phone format: +1234567890 (not 123-456-7890)
‚Ä¢ Get transcript: /transcript CA1234567890abcdef
‚Ä¢ List calls: /calls 20
‚Ä¢ Check health: /health
        
üÜò <b>Support &amp; Info</b>
‚Ä¢ Contact admin: @${config.admin.username}
‚Ä¢ Bot version: 2.0.0
‚Ä¢ For issues or questions, contact support`;
        
        const kb = new InlineKeyboard()
        .text('üìû New Call', 'CALL')
        .text('üìã Menu', 'MENU')
        .row()
        .text('üì± New SMS', 'SMS')
        .text('üìö Full Guide', 'GUIDE');
        
        if (isOwner) {
            kb.row()
            .text('üë• Users', 'USERS')
            .text('‚ûï Add User', 'ADDUSER');
        }
        
        await ctx.reply(helpText, {
            parse_mode: 'HTML',
            reply_markup: kb
        });
    } catch (error) {
        console.error('Help command error:', error);
        await ctx.reply('‚ùå Error displaying help. Please try again.');
    }
}

async function executeUsersCommand(ctx) {
    try {
        const { getUserList } = require('./db/db');
        
        const users = await new Promise((resolve, reject) => {
            getUserList((err, result) => {
                if (err) {
                    console.error('Database error in getUserList:', err);
                    reject(err);
                } else {
                    resolve(result);
                }
            });
        });

        if (!users || users.length === 0) {
            await ctx.reply('üìã No users found in the system.');
            return;
        }

        // Create user list without problematic markdown - use plain text
        let message = `üìã USERS LIST (${users.length}):\n\n`;
        
        users.forEach((user, index) => {
            const roleIcon = user.role === 'ADMIN' ? 'üõ°Ô∏è' : 'üë§';
            const username = user.username || 'no_username';
            const joinDate = new Date(user.timestamp).toLocaleDateString();
            message += `${index + 1}. ${roleIcon} @${username}\n`;
            message += `   ID: ${user.telegram_id}\n`;
            message += `   Role: ${user.role}\n`;
            message += `   Joined: ${joinDate}\n\n`;
        });

        // Send without parse_mode to avoid markdown parsing errors
        await ctx.reply(message);

    } catch (error) {
        console.error('executeUsersCommand error:', error);
        await ctx.reply('‚ùå Error fetching users list. Please try again.');
    }
}

async function executeGuideCommand(ctx) {
    const mainGuide = `üìö *Voice Call Bot Guide*

*Making Calls:*
1Ô∏è‚É£ Start a call using /call or the Call button
2Ô∏è‚É£ Enter phone number in E.164 format (+1234567890)
3Ô∏è‚É£ Define the AI agent's behavior/personality
4Ô∏è‚É£ Set the first message to be spoken
5Ô∏è‚É£ Monitor the call progress

*Phone Number Format:*
‚Ä¢ Must start with + symbol
‚Ä¢ Include country code
‚Ä¢ No spaces or special characters
‚Ä¢ Example: +1234567890

*Best Practices:*
‚Ä¢ Keep agent prompts clear and specific
‚Ä¢ Test with short calls first
‚Ä¢ Monitor initial responses
‚Ä¢ End calls if needed

*Troubleshooting:*
‚Ä¢ If call fails, check number format
‚Ä¢ Ensure proper authorization
‚Ä¢ Contact admin for persistent issues
‚Ä¢ Use /status to check bot health

*Need Help?*
Contact: @${config.admin.username} for support.
Version: 2.0.0`;

    const kb = new InlineKeyboard()
        .text('üìû New Call', 'CALL')
        .text('üìã Commands', 'HELP')
        .row()
        .text('üîÑ Main Menu', 'MENU')
        .text('New SMS', 'SMS');

    await ctx.reply(mainGuide, {
        parse_mode: 'Markdown',
        reply_markup: kb
    });
}

async function executeMenuCommand(ctx, isAdminUser) {
    const kb = new InlineKeyboard()
        .text('üìû New Call', 'CALL')
        .text('üì± Send SMS', 'SMS')
        .row()
        .text('üìã Recent Calls', 'CALLS')
        .text('üí¨ SMS Stats', 'SMS_STATS')
        .row()
        .text('üè• Health Check', 'HEALTH')
        .text('‚ÑπÔ∏è Help', 'HELP')
        .row()
        .text('üìö Guide', 'GUIDE');

    if (isAdminUser) {
        kb.row()
            .text('üì§ Bulk SMS', 'BULK_SMS')
            .text('‚è∞ Schedule SMS', 'SCHEDULE_SMS')
            .row()
            .text('‚ûï Add User', 'ADDUSER')
            .text('‚¨ÜÔ∏è Promote', 'PROMOTE')
            .row()
            .text('üë• Users', 'USERS')
            .text('‚ùå Remove', 'REMOVE')
            .row()
            .text('üîç Status', 'STATUS')
            .text('üß™ Test API', 'TEST_API');
    }

    const menuText = isAdminUser ? 
        'üõ°Ô∏è *Administrator Menu*\n\nSelect an action below:' :
        'üìã *Quick Actions Menu*\n\nSelect an action below:';

    await ctx.reply(menuText, {
        parse_mode: 'Markdown',
        reply_markup: kb
    });
}


async function executeHealthCommand(ctx) {
    const axios = require('axios');
    
    try {
        const startTime = Date.now();
        const response = await axios.get(`${config.apiUrl}/health`, {
            timeout: 5000
        });
        const responseTime = Date.now() - startTime;
        
        const health = response.data;
        
        let message = `üè• *Health Check*\n\n`;
        message += `ü§ñ Bot: ‚úÖ Responsive\n`;
        message += `üåê API: ${health.status === 'healthy' ? '‚úÖ' : '‚ùå'} ${health.status}\n`;
        message += `‚ö° Response Time: ${responseTime}ms\n`;
        message += `üìä Active Calls: ${health.active_calls || 0}\n`;
        message += `‚è∞ Checked: ${new Date().toLocaleTimeString()}`;
        
        await ctx.reply(message, { parse_mode: 'Markdown' });
    } catch (error) {
        console.error('Health command error:', error);
        await ctx.reply(`‚ùå *Health Check Failed*\n\nBot is online but API connection failed.\nError: ${error.message}`, { parse_mode: 'Markdown' });
    }
}

async function executeStatusCommand(ctx) {
    const axios = require('axios');
    
    try {
        const response = await axios.get(`${config.apiUrl}/health`, {
            timeout: 10000
        });
        
        const health = response.data;
        
        let message = `üîç *System Status*\n\n`;
        message += `ü§ñ Bot: ‚úÖ Online\n`;
        message += `üåê API: ${health.status === 'healthy' ? '‚úÖ' : '‚ùå'} ${health.status}\n`;
        message += `üóÑÔ∏è Database: ${health.services?.database?.connected ? '‚úÖ Connected' : '‚ùå Disconnected'}\n`;
        message += `üìä Active Calls: ${health.active_calls || 0}\n`;
        message += `üìã Recent Calls: ${health.services?.database?.recent_calls || 0}\n`;
        message += `üì° Webhook Service: ${health.services?.webhook_service?.status || 'Unknown'}\n`;
        message += `‚è∞ Last Check: ${new Date(health.timestamp).toLocaleString()}\n\n`;
        message += `üì° API Endpoint: ${config.apiUrl}`;
        
        await ctx.reply(message, { parse_mode: 'Markdown' });
    } catch (error) {
        console.error('Status command error:', error);
        await ctx.reply(`‚ùå *System Status Check Failed*\n\nError: ${error.message}`, { parse_mode: 'Markdown' });
    }
}

async function executeTestApiCommand(ctx) {
    const axios = require('axios');
    
    try {
        console.log('Testing API connection to:', config.apiUrl);
        const response = await axios.get(`${config.apiUrl}/health`, {
            timeout: 10000
        });
        
        const health = response.data;
        
        let message = `‚úÖ *API Status: ${health.status}*\n\n`;
        message += `üîó URL: ${config.apiUrl}\n`;
        message += `üìä Active Calls: ${health.active_calls || 0}\n`;
        message += `üóÑÔ∏è Database: ${health.services?.database?.connected ? '‚úÖ Connected' : '‚ùå Disconnected'}\n`;
        message += `‚è∞ Timestamp: ${new Date(health.timestamp).toLocaleString()}`;
        
        // Add enhanced features info if available
        if (health.enhanced_features) {
            message += `\nüöÄ Enhanced Features: ‚úÖ Active`;
        }
        
        await ctx.reply(message, { parse_mode: 'Markdown' });
    } catch (error) {
        console.error('API test failed:', error.message);
        await ctx.reply(`‚ùå *API Test Failed*\n\nURL: ${config.apiUrl}\nError: ${error.message}`, { parse_mode: 'Markdown' });
    }
}

async function executeCallsCommand(ctx) {
    const axios = require('axios');
    
    try {
        console.log('Executing calls command via callback...');
        
        let response;
        let calls = [];
        
        // Try multiple API endpoints in order of preference
        const endpoints = [
            `${config.apiUrl}/api/calls/list?limit=10`,  // Enhanced endpoint
            `${config.apiUrl}/api/calls?limit=10`,       // Basic endpoint
        ];
        
        let lastError = null;
        let successfulEndpoint = null;
        
        for (const endpoint of endpoints) {
            try {
                console.log(`Trying endpoint: ${endpoint}`);
                
                response = await axios.get(endpoint, {
                    timeout: 15000,
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json'
                    }
                });

                console.log(`Success! API Response status: ${response.status}`);
                successfulEndpoint = endpoint;
                
                // Handle different response structures
                if (response.data.calls) {
                    calls = response.data.calls;
                } else if (Array.isArray(response.data)) {
                    calls = response.data;
                } else {
                    console.log('Unexpected response structure:', Object.keys(response.data));
                    continue; // Try next endpoint
                }
                
                break; // Success, exit loop
                
            } catch (endpointError) {
                console.log(`Endpoint ${endpoint} failed:`, endpointError.message);
                lastError = endpointError;
                continue; // Try next endpoint
            }
        }
        
        // If all endpoints failed
        if (!calls || calls.length === 0) {
            if (lastError) {
                throw lastError; // Re-throw the last error for proper handling
            } else {
                return ctx.reply('üìã No calls found');
            }
        }

        console.log(`Successfully fetched ${calls.length} calls from: ${successfulEndpoint}`);

        let message = `üìã *Recent Calls* (${calls.length})\n\n`;

        calls.forEach((call, index) => {
            const date = new Date(call.created_at).toLocaleDateString();
            const duration = call.duration ? `${Math.floor(call.duration/60)}:${String(call.duration%60).padStart(2,'0')}` : 'N/A';
            const status = call.status || 'Unknown';
            const phoneNumber = call.phone_number;

            // Escape special characters for Markdown
            const escapedPhone = phoneNumber.replace(/[^\w\s+]/g, '\\$&');
            const escapedStatus = status.replace(/[^\w\s]/g, '\\$&');

            message += `${index + 1}\\. üìû ${escapedPhone}\n`;
            message += `   üÜî \`${call.call_sid}\`\n`;
            message += `   üìÖ ${date} \\| ‚è±Ô∏è ${duration} \\| üìä ${escapedStatus}\n`;
            message += `   üí¨ ${call.transcript_count || 0} messages\n\n`;
        });

        message += `Use /transcript <call\\_sid> to view details`;

        await ctx.reply(message, { parse_mode: 'Markdown' });

    } catch (error) {
        console.error('Error fetching calls list via callback:', error);
        
        // Provide specific error messages based on error type
        if (error.response?.status === 404) {
            await ctx.reply(
                '‚ùå *API Endpoints Missing*\n\n' +
                'The calls list endpoints are not available on the server\\.\n\n' +
                '*Missing endpoints:*\n' +
                '‚Ä¢ `/api/calls` \\- Basic calls listing\n' +
                '‚Ä¢ `/api/calls/list` \\- Enhanced calls listing\n\n' +
                'Please contact your system administrator to add these endpoints to the Express application\\.',
                { parse_mode: 'Markdown' }
            );
        } else if (error.code === 'ECONNREFUSED' || error.code === 'ENOTFOUND') {
            await ctx.reply(
                `‚ùå *Server Connection Failed*\n\n` +
                `Cannot connect to API server at:\n\`${config.apiUrl}\`\n\n` +
                `Please check if the server is running\\.`,
                { parse_mode: 'Markdown' }
            );
        } else if (error.response?.status === 500) {
            await ctx.reply('‚ùå Server error while fetching calls. Please try again later.');
        } else if (error.response) {
            await ctx.reply(`‚ùå API error (${error.response.status}): ${error.response.data?.error || 'Unknown error'}`);
        } else {
            await ctx.reply('‚ùå Error fetching calls list. Please try again later.');
        }
    }
}

// Mini App command handler
bot.command('miniapp', async (ctx) => {
    try {
        // Verify user authorization
        const user = await new Promise(r => getUser(ctx.from.id, r));
        if (!user) {
            return ctx.reply('‚ùå You are not authorized to use this bot.');
        }

        // Check if Mini App URL is configured
        if (!config.webAppUrl) {
            return ctx.reply('‚ùå Mini App is not configured. Please contact the administrator.');
        }

        const kb = new InlineKeyboard()
            .webApp('üöÄ Launch Mini App', config.webAppUrl);

        await ctx.reply(
            'üéØ *Voice Call Bot Mini App*\n\n' +
            'Access enhanced features through our Mini App:\n' +
            '‚Ä¢ üì± Modern interface\n' +
            '‚Ä¢ üöÄ Quick access to all features\n' +
            '‚Ä¢ üìä Real-time call monitoring\n' +
            '‚Ä¢ üí¨ Instant messaging\n\n' +
            'Click the button below to open the Mini App.',
            {
                parse_mode: 'Markdown',
                reply_markup: kb
            }
        );
    } catch (error) {
        console.error('Mini App command error:', error);
        await ctx.reply('‚ùå Error launching Mini App. Please try again or contact support.');
    }
});

// Register bot commands
bot.api.setMyCommands([
    { command: 'start', description: 'Start or restart the bot' },
    { command: 'miniapp', description: 'Open the Voice Call Mini App' },
    { command: 'call', description: 'Start outbound voice call' },
    { command: 'sms', description: 'Send SMS message' },
    { command: 'transcript', description: 'Get call transcript by SID' },
    { command: 'calls', description: 'List recent calls' },
    { command: 'smstemplates', description: 'View SMS templates' },
    { command: 'smsconversation', description: 'View SMS conversation' },
    { command: 'guide', description: 'Show detailed usage guide' },
    { command: 'help', description: 'Show available commands' },
    { command: 'menu', description: 'Show quick action menu' },
    { command: 'health', description: 'Check bot and API health' },
    { command: 'bulksms', description: 'Send bulk SMS (admin only)' },
    { command: 'schedulesms', description: 'Schedule SMS message' },
    { command: 'smsstats', description: 'SMS statistics (admin only)' },
    { command: 'smstemplate', description: 'View specific SMS template'},
    { command: 'adduser', description: 'Add user (admin only)' },
    { command: 'promote', description: 'Promote to ADMIN (admin only)' },
    { command: 'removeuser', description: 'Remove a USER (admin only)' },
    { command: 'users', description: 'List authorized users (admin only)' },
    { command: 'status', description: 'System status (admin only)' }
]);

// Handle unknown commands and text messages
bot.on('message:text', async (ctx) => {
    const text = ctx.message.text;
    
    // Skip if it's a command that's handled elsewhere
    if (text.startsWith('/')) {
        return;
    }
    
    // For non-command messages outside conversations
    if (!ctx.conversation) {
        await ctx.reply('üëã Use /help to see available commands or /menu for quick actions.');
    }
});

// Start the bot
console.log('üöÄ Starting Voice Call Bot...');
bot.start().then(() => {
    console.log('‚úÖ Voice Call Bot is running!');
    console.log('üîÑ Polling for updates...');
}).catch((error) => {
    console.error('‚ùå Failed to start bot:', error);
    process.exit(1);
});
