const config = require('../config');
const axios = require('axios');
const { getUser, isAdmin } = require('../db/db');

module.exports = (bot) => {
    // API test command (enhanced)
    bot.command('testapi', async (ctx) => {
        try {
            // Check if user is authorized and is admin
            const user = await new Promise(r => getUser(ctx.from.id, r));
            if (!user) {
                return ctx.reply('‚ùå You are not authorized to use this bot.');
            }

            const adminStatus = await new Promise(r => isAdmin(ctx.from.id, r));
            if (!adminStatus) {
                return ctx.reply('‚ùå This command is for administrators only.');
            }

            await ctx.reply('üß™ Testing API connection...');

            console.log('Testing API connection to:', config.apiUrl);
            const startTime = Date.now();
            const response = await axios.get(`${config.apiUrl}/health`, {
                timeout: 10000,
                headers: {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json'
                }
            });
            const responseTime = Date.now() - startTime;
            
            const health = response.data;
            console.log('API Health Response:', health);
            
            let message = `‚úÖ *API Status: ${health.status || 'healthy'}*\n\n`;
            message += `üîó URL: ${config.apiUrl}\n`;
            message += `‚ö° Response Time: ${responseTime}ms\n`;
            message += `üìä Active Calls: ${health.active_calls || 0}\n`;
            
            // Handle different response structures
            if (health.services) {
                const db = health.services.database;
                const webhook = health.services.webhook_service;
                
                message += `üóÑÔ∏è Database: ${db?.connected ? '‚úÖ Connected' : '‚ùå Disconnected'}\n`;
                message += `üìã Recent Calls: ${db?.recent_calls || 0}\n`;
                message += `üì° Webhook Service: ${webhook?.status || 'Unknown'}\n`;
                
                if (health.adaptation_engine) {
                    message += `ü§ñ Adaptation Engine: ‚úÖ Active\n`;
                    message += `üß© Function Templates: ${health.adaptation_engine.available_templates || 0}\n`;
                }
            } else {
                // Fallback for simpler health responses
                message += `üóÑÔ∏è Database: ${health.database_connected ? '‚úÖ Connected' : '‚ùå Unknown'}\n`;
            }
            
            message += `‚è∞ Timestamp: ${new Date(health.timestamp).toLocaleString()}\n`;
            
            // Add enhanced features info if available
            if (health.enhanced_features) {
                message += `\nüöÄ Enhanced Features: ‚úÖ Active`;
            }
            
            await ctx.reply(message, { parse_mode: 'Markdown' });
        } catch (error) {
            console.error('API test failed:', error);
            
            let errorMessage = `‚ùå *API Test Failed*\n\nURL: ${config.apiUrl}\n`;
            
            if (error.response) {
                errorMessage += `Status: ${error.response.status} - ${error.response.statusText}\n`;
                errorMessage += `Error: ${error.response.data?.error || error.message}`;
            } else if (error.code === 'ECONNREFUSED') {
                errorMessage += `Error: Connection refused - API server may be down`;
            } else if (error.code === 'ENOTFOUND') {
                errorMessage += `Error: Host not found - Check API URL`;
            } else if (error.code === 'ETIMEDOUT') {
                errorMessage += `Error: Request timeout - API server is not responding`;
            } else {
                errorMessage += `Error: ${error.message}`;
            }
            
            await ctx.reply(errorMessage, { parse_mode: 'Markdown' });
        }
    });

    // Status command (admin only) - Enhanced version
    bot.command('status', async (ctx) => {
        try {
            // Check if user is admin
            const user = await new Promise(r => getUser(ctx.from.id, r));
            const adminStatus = await new Promise(r => isAdmin(ctx.from.id, r));
            
            if (!user || !adminStatus) {
                return ctx.reply('‚ùå This command is for administrators only.');
            }

            await ctx.reply('üîç Checking system status...');

            const startTime = Date.now();
            const response = await axios.get(`${config.apiUrl}/health`, {
                timeout: 15000,
                headers: {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json'
                }
            });
            const responseTime = Date.now() - startTime;
            
            const health = response.data;
            
            let message = `üîç *System Status Report*\n\n`;
            message += `ü§ñ Bot: ‚úÖ Online & Responsive\n`;
            message += `üåê API: ${health.status === 'healthy' ? '‚úÖ' : '‚ùå'} ${health.status || 'healthy'}\n`;
            message += `‚ö° API Response Time: ${responseTime}ms\n\n`;
            
            // Enhanced service status
            if (health.services) {
                message += `*üîß Services Status:*\n`;
                
                const db = health.services.database;
                message += `üóÑÔ∏è Database: ${db?.connected ? '‚úÖ Connected' : '‚ùå Disconnected'}\n`;
                if (db?.recent_calls !== undefined) {
                    message += `üìã Recent DB Calls: ${db.recent_calls}\n`;
                }
                
                const webhook = health.services.webhook_service;
                if (webhook) {
                    message += `üì° Webhook Service: ${webhook.status === 'running' ? '‚úÖ' : '‚ö†Ô∏è'} ${webhook.status}\n`;
                    if (webhook.processed_today !== undefined) {
                        message += `üì® Webhooks Today: ${webhook.processed_today}\n`;
                    }
                }
                
                const notifications = health.services.notification_system;
                if (notifications) {
                    message += `üîî Notifications: ${notifications.success_rate || 'N/A'} success rate\n`;
                }
                
                message += `\n`;
            }
            
            // Call statistics
            message += `*üìä Call Statistics:*\n`;
            message += `üìû Active Calls: ${health.active_calls || 0}\n`;
            
            // Enhanced features
            if (health.adaptation_engine) {
                message += `\n*ü§ñ AI Features:*\n`;
                message += `üß† Adaptation Engine: ‚úÖ Active\n`;
                message += `üß© Function Templates: ${health.adaptation_engine.available_templates || 0}\n`;
                message += `‚öôÔ∏è Active Systems: ${health.adaptation_engine.active_function_systems || 0}\n`;
            }
            
            if (health.enhanced_features) {
                message += `üöÄ Enhanced Features: ‚úÖ Enabled\n`;
            }
            
            // System health logs (if available)
            if (health.system_health && health.system_health.length > 0) {
                message += `\n*üîç Recent Activity:*\n`;
                health.system_health.slice(0, 3).forEach(log => {
                    const status = log.status === 'error' ? '‚ùå' : '‚úÖ';
                    message += `${status} ${log.service_name}: ${log.count} ${log.status}\n`;
                });
            }
            
            message += `\n‚è∞ Last Updated: ${new Date(health.timestamp).toLocaleString()}`;
            message += `\nüì° API Endpoint: ${config.apiUrl}`;
            
            await ctx.reply(message, { parse_mode: 'Markdown' });
        } catch (error) {
            console.error('Status command error:', error);
            
            let errorMessage = `‚ùå *System Status Check Failed*\n\n`;
            errorMessage += `ü§ñ Bot: ‚úÖ Online (you're seeing this message)\n`;
            errorMessage += `üåê API: ‚ùå Connection failed\n\n`;
            
            if (error.response) {
                errorMessage += `üìä API Status: ${error.response.status} - ${error.response.statusText}\n`;
                errorMessage += `üìù Error Details: ${error.response.data?.error || 'Unknown API error'}\n`;
            } else if (error.code === 'ECONNREFUSED') {
                errorMessage += `üìù Error: API server connection refused\n`;
                errorMessage += `üí° Suggestion: Check if the API server is running\n`;
            } else if (error.code === 'ENOTFOUND') {
                errorMessage += `üìù Error: API server not found\n`;
                errorMessage += `üí° Suggestion: Verify API URL configuration\n`;
            } else {
                errorMessage += `üìù Error: ${error.message}\n`;
            }
            
            errorMessage += `\nüì° API Endpoint: ${config.apiUrl}`;
            
            await ctx.reply(errorMessage, { parse_mode: 'Markdown' });
        }
    });

    // Health check command (simple version for all users) - Enhanced
    bot.command(['health', 'ping'], async (ctx) => {
        try {
            const user = await new Promise(r => getUser(ctx.from.id, r));
            if (!user) {
                return ctx.reply('‚ùå You are not authorized to use this bot.');
            }

            const startTime = Date.now();
            
            try {
                const response = await axios.get(`${config.apiUrl}/health`, {
                    timeout: 8000,
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json'
                    }
                });
                const responseTime = Date.now() - startTime;
                
                const health = response.data;
                
                let message = `üè• *Health Check*\n\n`;
                message += `ü§ñ Bot: ‚úÖ Responsive\n`;
                message += `üåê API: ${health.status === 'healthy' ? '‚úÖ' : '‚ö†Ô∏è'} ${health.status || 'responding'}\n`;
                message += `‚ö° Response Time: ${responseTime}ms\n`;
                
                // Add basic stats if available
                if (health.active_calls !== undefined) {
                    message += `üìû Active Calls: ${health.active_calls}\n`;
                }
                
                // Add database status if available
                if (health.services?.database?.connected !== undefined) {
                    message += `üóÑÔ∏è Database: ${health.services.database.connected ? '‚úÖ' : '‚ùå'} ${health.services.database.connected ? 'Connected' : 'Disconnected'}\n`;
                }
                
                message += `‚è∞ Checked: ${new Date().toLocaleTimeString()}`;
                
                await ctx.reply(message, { parse_mode: 'Markdown' });
            } catch (apiError) {
                const responseTime = Date.now() - startTime;
                
                let message = `üè• *Health Check*\n\n`;
                message += `ü§ñ Bot: ‚úÖ Responsive\n`;
                message += `üåê API: ‚ùå Connection failed\n`;
                message += `‚ö° Response Time: ${responseTime}ms (timeout)\n`;
                message += `‚è∞ Checked: ${new Date().toLocaleTimeString()}\n\n`;
                
                if (apiError.code === 'ECONNREFUSED') {
                    message += `üìù API server appears to be down`;
                } else if (apiError.code === 'ETIMEDOUT') {
                    message += `üìù API server is not responding (timeout)`;
                } else {
                    message += `üìù ${apiError.message}`;
                }
                
                await ctx.reply(message, { parse_mode: 'Markdown' });
            }
        } catch (error) {
            console.error('Health command error:', error);
            await ctx.reply(`üè• *Health Check*\n\nü§ñ Bot: ‚úÖ Responsive\nüåê API: ‚ùå Error\n‚è∞ Checked: ${new Date().toLocaleTimeString()}\n\nüìù ${error.message}`, { parse_mode: 'Markdown' });
        }
    });
};
