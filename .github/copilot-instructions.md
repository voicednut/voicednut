# VoicedNut AI Agent Instructions

## System Architecture

This is a Telegram bot system for AI-powered voice calls with three main components:

1. **Telegram Bot (`/bot`)**: Grammy.js-based bot handling user interactions and call management
2. **API Server (`/api`)**: Express.js server managing calls, AI, and real-time audio
3. **Mini App (`/mini-app`)**: React + TypeScript Telegram WebApp for enhanced UI interactions
   - Built using `@telegram-apps/create-mini-app` CLI
   - Integrates with Telegram via `@telegram-apps/sdk` (tma.js)
   - Provides rich UI flows for all bot features
   - Hosted on Vercel and linked to bot

Key integration points:
- Twilio for voice calls (`api/routes/stream.js`)
- OpenRouter for AI models (`api/routes/gpt.js`)
- Deepgram for transcription (`api/routes/transcription.js`)
- SQLite for data persistence (`api/db/db.js`, `bot/db/db.js`)

## Core Patterns

### AI Response Formatting
- All AI responses must include '•' symbols every 5-10 words at natural pauses for TTS chunking
- Example: `Hello! • How can I assist you • with your call today?`
- See `api/routes/gpt.js` implementation

### Dynamic Function System
- Business logic is implemented through adaptable function templates
- New functions must follow the template pattern in `api/functions/DynamicFunctionEngine.js`
- Each function requires:
  - Name, description, parameter schema
  - Implementation method
  - Business context integration

### Personality Engine
- AI responses adapt based on conversation context
- Personality profiles defined in `api/functions/PersonalityEngine.js`
- Track and update user context during conversations:
  ```js
  {
    customerMood: string,
    communicationStyle: string,
    urgencyLevel: string,
    techSavviness: string
  }
  ```

## Development Workflow

1. Setup environment:
   ```bash
   # In /api directory
   cp .env.example .env
   npm install
   # Start ngrok tunnel
   ngrok http 3000
   # Update .env with ngrok URL
   ```

2. Test changes:
   ```bash
   # Run API tests
   cd api && npm test
   # Run bot tests
   cd bot && npm test
   ```

3. Run locally:
   ```bash
   # Start API server
   cd api && npm start
   # Start bot in separate terminal
   cd bot && npm start
   ```

## Critical Files

- `api/functions/DynamicFunctionEngine.js` - Core business logic templates
- `api/functions/PersonalityEngine.js` - Conversation adaptation system
- `api/routes/gpt.js` - AI model integration and response handling
- `bot/commands/*.js` - Telegram command implementations
- `api/routes/stream.js` - Real-time audio processing

copilot-instructions.md
New
+64
-0

# Copilot Instructions for Telegram Mini App Development

## Project Context
- Build a new Telegram Mini App that complements the existing bot by providing a beautiful, responsive interface for every command the bot supports.
- All mini app source code must live under `/mini-app`. Follow the structure generated by `@telegram-apps/create-mini-app@latest`, but keep the implementation modular and aligned with the repo's conventions.
- The mini app should communicate seamlessly with the existing backend services in `/api` and `/bot` without duplicating business logic.

## Initial Setup
1. `cd /mini-app`
2. The project is already Scaffold with `npx @telegram-apps/create-mini-app@latest` In /mini-app So you dont need to scaffold new one anymore(consult the package documentation for options).
3. Install dependencies:
   ```bash
   npm install
   npm install @telegram-apps/sdk tma.js
   ```
4. Configure local environment variables to mirror backend expectations (reuse `.env` patterns from the main project if available).

## Architecture & Design Principles
- **Feature Parity:** Convert every existing bot command into an intuitive UI flow (forms, dashboards, or action panels). Ensure parity and leverage existing API endpoints rather than re-implementing logic.
- **Layered Structure:**
  - `components/` for reusable UI elements.
  - `features/` for domain-specific flows (call monitoring, transcription, user management, configuration, etc.).
  - `services/` for API clients, state managers, and integrations with the Telegram WebApp SDK.
  - `stores/` or `state/` for context/state management (prefer lightweight solutions like Zustand or custom hooks).
- **Async Coordination:** Use event emitters (mirroring the pattern in `EnhancedGptService`) to coordinate asynchronous flows (e.g., streaming transcripts, call status updates).
- **State Management:** Maintain conversational context in memory where possible. Persist only essential data to SQLite through existing backend endpoints.
- **Responsiveness:** Design layouts that adapt gracefully to mobile, tablet, and desktop Telegram clients.

## Telegram Integration Guidelines
- Use `@telegram-apps/sdk` and `tma.js` to access Telegram WebApp features (haptic feedback, theme detection, viewport management, etc.).
- Initialize the Telegram SDK early in the app lifecycle and expose helpers for theme updates and closing/minimizing the app.
- Follow official Telegram WebApp design guidance (compact UI, large tap targets, dark/light theme support).
- Test flows inside the Telegram client and in development mode to ensure consistent behavior.

## Feature Checklist
1. **Command Flows:** UI for all existing bot commands with clear navigation.
2. **Real-Time Call Monitoring:** Dashboard showing active calls, status updates, and controls, fed by backend events.
3. **Interactive Transcription Viewer:** Live transcript stream with search/highlight features and download/export options.
4. **User Management Dashboard:** Role-based views, filters, and actions to manage users.
5. **System Configuration Panels:** Admin tools for configuring service settings, API keys, and operational modes.

## Communication with Backend
- Reuse API endpoints from `/api`. Add new endpoints only when absolutely necessary and update backend tests accordingly.
- For long-lived connections (e.g., real-time monitoring), use web sockets or SSE if supported, otherwise implement efficient polling with exponential backoff.
- Validate all payloads and handle errors gracefully, showing actionable messages in the UI.

## Testing & Quality Assurance
- For backend changes or new endpoints, add or update tests in `api/test/` and run the full test suite.
- Implement frontend unit/integration tests (e.g., with Vitest + Testing Library) for critical flows and components.
- Manually verify the mini app both in Telegram client and in a local dev environment.
- Lint and format consistently (configure ESLint/Prettier as part of the scaffold).

## Deployment Workflow
- Prepare production build optimized for Vercel deployment (configure `vercel.json` if adjustments are needed).
- Set up CI to run tests and lint checks for `/mini-app` before deployment.
- Document deployment steps and environment variables required by Vercel.

## Additional Guidance
- Review examples and patterns in `/mini-sample` for ideas, but do not copy code or reuse the `server` folder from the sample.
- Keep feature modules decoupled so they can evolve independently.
- Ensure accessibility (ARIA labels, keyboard navigation, sufficient contrast) alongside visual polish.
- Provide meaningful README or in-app documentation for future contributors.

Following this guide will help Copilot produce a robust, well-structured, and production-ready Telegram Mini App that aligns with the existing bot's capabilities.
